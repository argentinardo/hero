# Aplicaci√≥n de Principios SOLID al Proyecto H.E.R.O.

## üìö √çndice
1. [¬øQu√© es SOLID?](#qu√©-es-solid)
2. [An√°lisis del C√≥digo Actual](#an√°lisis-del-c√≥digo-actual)
3. [Violaciones Identificadas](#violaciones-identificadas)
4. [Plan de Refactorizaci√≥n](#plan-de-refactorizaci√≥n)
5. [Implementaci√≥n](#implementaci√≥n)

---

## ¬øQu√© es SOLID?

SOLID es un acr√≥nimo de cinco principios de dise√±o orientado a objetos que ayudan a crear software m√°s mantenible, escalable y robusto.

### S - Single Responsibility Principle (SRP)
**Principio de Responsabilidad √önica**

> "Una clase debe tener una, y solo una, raz√≥n para cambiar"

**Significado:** Cada m√≥dulo, clase o funci√≥n debe tener una sola responsabilidad o prop√≥sito. Si un m√≥dulo hace demasiadas cosas, se vuelve dif√≠cil de mantener y probar.

**Ejemplo Simple:**
```typescript
// ‚ùå VIOLACI√ìN: Esta clase tiene m√∫ltiples responsabilidades
class User {
    name: string;
    
    saveToDatabase() { /* ... */ }  // Responsabilidad: persistencia
    sendEmail() { /* ... */ }       // Responsabilidad: comunicaci√≥n
    calculateAge() { /* ... */ }    // Responsabilidad: l√≥gica de negocio
}

// ‚úÖ CORRECTO: Cada clase tiene una √∫nica responsabilidad
class User {
    name: string;
    calculateAge() { /* ... */ }
}

class UserRepository {
    saveToDatabase(user: User) { /* ... */ }
}

class EmailService {
    sendEmail(user: User) { /* ... */ }
}
```

---

### O - Open/Closed Principle (OCP)
**Principio Abierto/Cerrado**

> "Las entidades de software deben estar abiertas para extensi√≥n, pero cerradas para modificaci√≥n"

**Significado:** Debes poder agregar nueva funcionalidad sin modificar el c√≥digo existente. Esto se logra usando abstrac ciones (interfaces) y polimorfismo.

**Ejemplo Simple:**
```typescript
// ‚ùå VIOLACI√ìN: Para agregar un nuevo tipo, hay que modificar el c√≥digo existente
function calculateArea(shape: any) {
    if (shape.type === 'circle') {
        return Math.PI * shape.radius ** 2;
    } else if (shape.type === 'rectangle') {
        return shape.width * shape.height;
    }
    // Para agregar triangulo, hay que modificar esta funci√≥n
}

// ‚úÖ CORRECTO: Abierto para extensi√≥n, cerrado para modificaci√≥n
interface Shape {
    calculateArea(): number;
}

class Circle implements Shape {
    constructor(private radius: number) {}
    calculateArea(): number {
        return Math.PI * this.radius ** 2;
    }
}

class Rectangle implements Shape {
    constructor(private width: number, private height: number) {}
    calculateArea(): number {
        return this.width * this.height;
    }
}

// Puedo agregar nuevas formas sin modificar c√≥digo existente
class Triangle implements Shape {
    constructor(private base: number, private height: number) {}
    calculateArea(): number {
        return (this.base * this.height) / 2;
    }
}
```

---

### L - Liskov Substitution Principle (LSP)
**Principio de Sustituci√≥n de Liskov**

> "Los objetos de una superclase deben poder ser reemplazados por objetos de sus subclases sin romper la aplicaci√≥n"

**Significado:** Las clases derivadas deben poder sustituir a sus clases base sin que el programa deje de funcionar correctamente.

**Ejemplo Simple:**
```typescript
// ‚ùå VIOLACI√ìN: Square viola LSP porque cambia el comportamiento esperado
class Rectangle {
    constructor(protected width: number, protected height: number) {}
    
    setWidth(width: number) { this.width = width; }
    setHeight(height: number) { this.height = height; }
    
    getArea() { return this.width * this.height; }
}

class Square extends Rectangle {
    setWidth(width: number) {
        this.width = width;
        this.height = width; // Comportamiento inesperado!
    }
    
    setHeight(height: number) {
        this.width = height;  // Comportamiento inesperado!
        this.height = height;
    }
}

// C√≥digo que usa Rectangle
function test(rect: Rectangle) {
    rect.setWidth(5);
    rect.setHeight(4);
    console.log(rect.getArea()); // Esperamos 20, pero con Square obtenemos 16
}

// ‚úÖ CORRECTO: Usar composici√≥n en lugar de herencia
interface Shape {
    getArea(): number;
}

class Rectangle implements Shape {
    constructor(private width: number, private height: number) {}
    getArea() { return this.width * this.height; }
}

class Square implements Shape {
    constructor(private side: number) {}
    getArea() { return this.side ** 2; }
}
```

---

### I - Interface Segregation Principle (ISP)
**Principio de Segregaci√≥n de Interfaces**

> "Los clientes no deben ser forzados a depender de interfaces que no usan"

**Significado:** Es mejor tener varias interfaces espec√≠ficas que una grande y general. Las clases no deber√≠an implementar m√©todos que no necesitan.

**Ejemplo Simple:**
```typescript
// ‚ùå VIOLACI√ìN: Interfaz demasiado grande
interface Worker {
    work(): void;
    eat(): void;
    sleep(): void;
}

class Human implements Worker {
    work() { /* ... */ }
    eat() { /* ... */ }
    sleep() { /* ... */ }
}

class Robot implements Worker {
    work() { /* ... */ }
    eat() { throw new Error("Robots don't eat!"); } // ‚ùå M√©todo innecesario
    sleep() { throw new Error("Robots don't sleep!"); } // ‚ùå M√©todo innecesario
}

// ‚úÖ CORRECTO: Interfaces segregadas
interface Workable {
    work(): void;
}

interface Eatable {
    eat(): void;
}

interface Sleepable {
    sleep(): void;
}

class Human implements Workable, Eatable, Sleepable {
    work() { /* ... */ }
    eat() { /* ... */ }
    sleep() { /* ... */ }
}

class Robot implements Workable {
    work() { /* ... */ } // Solo implementa lo que necesita
}
```

---

### D - Dependency Inversion Principle (DIP)
**Principio de Inversi√≥n de Dependencias**

> "Depende de abstracciones, no de concreciones"

**Significado:** Los m√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel. Ambos deben depender de abstracciones (interfaces).

**Ejemplo Simple:**
```typescript
// ‚ùå VIOLACI√ìN: Alto acoplamiento
class MySQLDatabase {
    save(data: string) { /* guardar en MySQL */ }
}

class UserService {
    private database = new MySQLDatabase(); // ‚ùå Dependencia directa de implementaci√≥n
    
    saveUser(user: string) {
        this.database.save(user);
    }
}

// ‚úÖ CORRECTO: Inyecci√≥n de dependencias con abstracciones
interface Database {
    save(data: string): void;
}

class MySQLDatabase implements Database {
    save(data: string) { /* guardar en MySQL */ }
}

class MongoDatabase implements Database {
    save(data: string) { /* guardar en MongoDB */ }
}

class UserService {
    // Depende de la abstracci√≥n, no de la implementaci√≥n
    constructor(private database: Database) {}
    
    saveUser(user: string) {
        this.database.save(user);
    }
}

// Uso: puedo cambiar la implementaci√≥n f√°cilmente
const service1 = new UserService(new MySQLDatabase());
const service2 = new UserService(new MongoDatabase());
```

---

## An√°lisis del C√≥digo Actual

### Estructura Actual del Proyecto
```
src/scripts/
‚îú‚îÄ‚îÄ main.ts              # Punto de entrada, game loop
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ state.ts         # Estado global del juego
‚îÇ   ‚îú‚îÄ‚îÄ types.ts         # Definiciones de tipos
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts     # Constantes
‚îÇ   ‚îú‚îÄ‚îÄ collision.ts     # Detecci√≥n de colisiones
‚îÇ   ‚îî‚îÄ‚îÄ assets.ts        # Carga de recursos
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ player.ts        # L√≥gica del jugador
    ‚îú‚îÄ‚îÄ enemy.ts         # L√≥gica de enemigos
    ‚îú‚îÄ‚îÄ bomb.ts          # L√≥gica de bombas/explosiones
    ‚îú‚îÄ‚îÄ laser.ts         # L√≥gica de l√°seres
    ‚îú‚îÄ‚îÄ level.ts         # Gesti√≥n de niveles
    ‚îú‚îÄ‚îÄ light.ts         # Sistema de iluminaci√≥n
    ‚îú‚îÄ‚îÄ render.ts        # Renderizado
    ‚îú‚îÄ‚îÄ ui.ts            # Interfaz de usuario
    ‚îî‚îÄ‚îÄ effects.ts       # Efectos visuales
```

---

## Violaciones Identificadas

### 1. ‚ùå Violaci√≥n de SRP (Single Responsibility)

#### `player.ts`
```typescript
// Este archivo hace DEMASIADAS cosas:
// 1. Manejo de input del jugador
// 2. F√≠sica del movimiento
// 3. Colisiones
// 4. Animaciones
// 5. Muerte del jugador
// 6. Emisi√≥n de part√≠culas
// 7. Manejo del vuelo/jet pack
```

**Problema:** Si necesitas cambiar la l√≥gica de animaci√≥n, tienes que modificar el mismo archivo que maneja las colisiones. Esto aumenta el riesgo de introducir bugs.

#### `main.ts`
```typescript
// Responsabilidades:
// 1. Inicializaci√≥n del juego
// 2. Game loop
// 3. Gesti√≥n de estado
// 4. Actualizaci√≥n de c√°mara
// 5. Chequeo de rescate del minero
```

---

### 2. ‚ùå Violaci√≥n de OCP (Open/Closed)

#### `enemy.ts` - Sistema de Enemigos
```typescript
export const updateEnemies = (store: GameStore) => {
    store.enemies.forEach(enemy => {
        switch (enemy.type) {
            case 'bat': { /* l√≥gica espec√≠fica */ break; }
            case 'spider': { /* l√≥gica espec√≠fica */ break; }
            case 'viper': { /* l√≥gica espec√≠fica */ break; }
        }
    });
};
```

**Problema:** Para agregar un nuevo tipo de enemigo, tienes que:
1. Modificar la funci√≥n `updateEnemies` (violando OCP)
2. Agregar un nuevo case al switch
3. Modificar el renderizado
4. Potencialmente romper la l√≥gica existente

**Soluci√≥n esperada:** Deber√≠amos poder agregar nuevos enemigos sin modificar c√≥digo existente.

---

### 3. ‚ùå Violaci√≥n de ISP (Interface Segregation)

#### `types.ts` - Enemy Interface
```typescript
export interface Enemy extends GameObject {
    vx: number;
    vy: number;
    type: EnemyType;
    tile: string;
    direction?: number;        // Solo viper
    initialX?: number;         // Solo viper
    initialY?: number;         // Spider y bat
    maxLength?: number;        // Solo spider
    state?: string;            // Solo viper
    idleTimer?: number;        // Solo viper
    waitTimer?: number;        // Solo viper
    spriteTick: number;
    movementTick?: number;     // Solo bat
    currentFrame: number;
    // ...
}
```

**Problema:** Todos los enemigos usan la misma interfaz, pero cada tipo solo usa algunos campos. Esto es confuso y propenso a errores.

---

### 4. ‚ùå Violaci√≥n de DIP (Dependency Inversion)

#### Acoplamiento Directo con GameStore
```typescript
// Todas las funciones dependen directamente del GameStore global
export const updatePlayer = (store: GameStore) => { /* ... */ }
export const updateEnemies = (store: GameStore) => { /* ... */ }
export const renderGame = (store: GameStore) => { /* ... */ }
```

**Problema:** 
- Todo est√° acoplado al store global
- Dif√≠cil de testear (necesitas el store completo)
- Dif√≠cil de reutilizar funciones
- No puedes cambiar la implementaci√≥n del estado f√°cilmente

---

### 5. ‚ùå Falta de Abstracci√≥n en Renderizado

#### `render.ts`
```typescript
// L√≥gica de renderizado mezclada con l√≥gica de negocio
const drawGameWorld = (store: GameStore) => {
    // Acceso directo a propiedades del store
    ctx.fillStyle = 'black';
    store.walls.forEach(wall => drawWall(store, wall));
    store.enemies.forEach(enemy => drawEnemy(store, enemy));
    // ...
}
```

**Problema:** El renderizador est√° fuertemente acoplado al store y conoce detalles de implementaci√≥n.

---

## Plan de Refactorizaci√≥n

### Fase 1: Aplicar SRP - Separar Responsabilidades

#### 1.1 Separar `player.ts` en:
- `PlayerInputHandler.ts` - Manejo de input
- `PlayerPhysics.ts` - F√≠sica y movimiento
- `PlayerCollisionResolver.ts` - Resoluci√≥n de colisiones
- `PlayerAnimator.ts` - Animaciones
- `Player.ts` - Clase principal que coordina

#### 1.2 Separar `main.ts` en:
- `Game.ts` - Clase principal del juego
- `GameLoop.ts` - Loop del juego
- `CameraController.ts` - Control de c√°mara

---

### Fase 2: Aplicar OCP - Sistema Extensible de Enemigos

#### 2.1 Crear jerarqu√≠a de enemigos:
```typescript
interface IEnemy {
    update(context: GameContext): void;
    render(renderer: Renderer): void;
}

class BatEnemy implements IEnemy { /* ... */ }
class SpiderEnemy implements IEnemy { /* ... */ }
class ViperEnemy implements IEnemy { /* ... */ }
```

---

### Fase 3: Aplicar ISP - Interfaces Segregadas

#### 3.1 Separar interfaces de enemigos:
```typescript
interface IMovable { /* ... */ }
interface IAnimatable { /* ... */ }
interface ICollidable { /* ... */ }

class BatEnemy implements IMovable, IAnimatable, ICollidable { /* ... */ }
```

---

### Fase 4: Aplicar DIP - Inyecci√≥n de Dependencias

#### 4.1 Crear abstracciones:
```typescript
interface IGameState { /* ... */ }
interface IRenderer { /* ... */ }
interface IInputProvider { /* ... */ }

class Game {
    constructor(
        private state: IGameState,
        private renderer: IRenderer,
        private input: IInputProvider
    ) {}
}
```

---

### Fase 5: Aplicar LSP - Jerarqu√≠as Correctas

#### 5.1 Revisar herencias y usar composici√≥n donde sea apropiado

---

## Implementaci√≥n

La implementaci√≥n se realizar√° en archivos separados para mantener compatibilidad y poder comparar:

```
src/scripts/solid/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îú‚îÄ‚îÄ Player/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Player.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlayerInputHandler.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlayerPhysics.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlayerCollisionResolver.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PlayerAnimator.ts
‚îÇ   ‚îî‚îÄ‚îÄ enemies/
‚îÇ       ‚îú‚îÄ‚îÄ IEnemy.ts
‚îÇ       ‚îú‚îÄ‚îÄ BaseEnemy.ts
‚îÇ       ‚îú‚îÄ‚îÄ BatEnemy.ts
‚îÇ       ‚îú‚îÄ‚îÄ SpiderEnemy.ts
‚îÇ       ‚îî‚îÄ‚îÄ ViperEnemy.ts
‚îú‚îÄ‚îÄ systems/
‚îÇ   ‚îú‚îÄ‚îÄ GameLoop.ts
‚îÇ   ‚îú‚îÄ‚îÄ CameraController.ts
‚îÇ   ‚îî‚îÄ‚îÄ CollisionSystem.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ IRenderer.ts
‚îÇ   ‚îú‚îÄ‚îÄ CanvasRenderer.ts
‚îÇ   ‚îú‚îÄ‚îÄ IGameState.ts
‚îÇ   ‚îî‚îÄ‚îÄ GameState.ts
‚îî‚îÄ‚îÄ Game.ts
```

---

## Beneficios de Aplicar SOLID

### 1. **Mantenibilidad**
- C√≥digo m√°s f√°cil de entender
- Cambios localizados (no efecto domin√≥)
- Menos bugs al modificar

### 2. **Testabilidad**
- Componentes aislados f√°ciles de testear
- Puedes inyectar mocks/stubs
- Tests unitarios m√°s simples

### 3. **Escalabilidad**
- F√°cil agregar nuevas caracter√≠sticas
- C√≥digo reutilizable
- Extensible sin romper lo existente

### 4. **Colaboraci√≥n**
- C√≥digo m√°s profesional
- Est√°ndares claros
- F√°cil para nuevos desarrolladores

---

## Pr√≥ximos Pasos

1. Crear estructura de carpetas `solid/`
2. Implementar Player siguiendo SRP
3. Implementar sistema de enemigos siguiendo OCP/ISP
4. Aplicar DIP con inyecci√≥n de dependencias
5. Migrar gradualmente el c√≥digo existente
6. Documentar cada decisi√≥n

---

**Nota:** Esta refactorizaci√≥n es educativa. El c√≥digo original funciona, pero aplicando SOLID lo hacemos m√°s profesional y mantenible. ¬°Excelente ejercicio de aprendizaje! üöÄ

