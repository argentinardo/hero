# üé§ Gu√≠a para Entrevista T√©cnica - Proyecto H.E.R.O.

Esta gu√≠a te ayudar√° a explicar las decisiones t√©cnicas del proyecto a l√≠deres t√©cnicos durante entrevistas.

## üìö √çndice

1. [Preparaci√≥n General](#preparaci√≥n-general)
2. [Preguntas Comunes y Respuestas](#preguntas-comunes-y-respuestas)
3. [Explicaci√≥n de Decisiones Arquitect√≥nicas](#explicaci√≥n-de-decisiones-arquitect√≥nicas)
4. [Principios SOLID en Pr√°ctica](#principios-solid-en-pr√°ctica)
5. [Demostraci√≥n de C√≥digo](#demostraci√≥n-de-c√≥digo)
6. [Preguntas para Hacer](#preguntas-para-hacer)

---

## üéØ Preparaci√≥n General

### Antes de la Entrevista

1. **Revisa la documentaci√≥n**:
   - Lee `ARCHITECTURE_DECISIONS.md` completamente
   - Familiar√≠zate con `SOLID_REFACTORING.md`
   - Revisa la estructura de `src/scripts/solid/`

2. **Prepara ejemplos de c√≥digo**:
   - Identifica 3-5 funciones clave que demuestren buenas pr√°cticas
   - Ten listos ejemplos de c√≥digo antes/despu√©s (si aplica)

3. **Piensa en desaf√≠os**:
   - ¬øQu√© problemas t√©cnicos encontraste?
   - ¬øC√≥mo los resolviste?
   - ¬øQu√© har√≠as diferente ahora?

---

## üí¨ Preguntas Comunes y Respuestas

### Pregunta 1: "¬øPor qu√© elegiste esta arquitectura?"

**Respuesta Preparada**:

> "Eleg√≠ una arquitectura modular con separaci√≥n por responsabilidades por varias razones:
> 
> 1. **Escalabilidad**: Facilita agregar nuevas caracter√≠sticas sin modificar c√≥digo existente
> 2. **Mantenibilidad**: Cada componente tiene una responsabilidad clara, lo que facilita el debugging
> 3. **Testabilidad**: Componentes aislados son m√°s f√°ciles de testear unitariamente
> 4. **Colaboraci√≥n**: M√∫ltiples desarrolladores pueden trabajar en paralelo sin conflictos
> 
> Adem√°s, implement√© principios SOLID, especialmente el Single Responsibility Principle, separando la l√≥gica de renderizado de la l√≥gica de negocio, y el Dependency Inversion Principle en la refactorizaci√≥n (visible en `src/scripts/solid/`).
> 
> Puedo mostrar c√≥mo esto facilit√≥ agregar nuevos enemigos sin modificar c√≥digo existente."

**Apoyo Visual**: Mostrar estructura de carpetas y ejemplo de extensi√≥n de enemigos.

---

### Pregunta 2: "¬øPor qu√© usaste estado global en lugar de estado local?"

**Respuesta Preparada**:

> "Decid√≠ usar un estado global centralizado (`GameStore`) porque:
> 
> 1. **Interdependencia**: Los sistemas del juego (player, enemies, UI, audio) necesitan compartir estado constantemente
> 2. **Simplicidad**: Evita prop drilling excesivo
> 3. **Debugging**: Un solo lugar para inspeccionar el estado completo facilita el debugging
> 
> Sin embargo, reconozco que esto puede crecer mucho. Por eso:
> - Document√© claramente qu√© propiedades pertenecen a cada sistema
> - Implement√© una versi√≥n con inyecci√≥n de dependencias en `src/scripts/solid/` que muestra el camino hacia una arquitectura m√°s desacoplada
> 
> En un proyecto m√°s grande, migrar√≠a gradualmente hacia abstracciones con interfaces."

**Apoyo Visual**: Mostrar `GameStore` interface y c√≥mo se usa.

---

### Pregunta 3: "¬øPor qu√© Canvas API en lugar de WebGL o una librer√≠a?"

**Respuesta Preparada**:

> "Eleg√≠ Canvas 2D API nativo por varias razones:
> 
> 1. **Control total**: Necesitaba control preciso sobre el rendering para pixel art
> 2. **Bundle size**: No quer√≠a agregar dependencias pesadas (Phaser/Pixi.js a√±aden ~200KB+)
> 3. **Simplicidad**: Para un juego 2D simple, Canvas API es suficiente y m√°s f√°cil de entender
> 4. **Performance**: Para este caso de uso (pixel art, no muchos objetos), Canvas es m√°s eficiente
> 
> Configur√© el contexto con optimizaciones:
> - `alpha: false` porque no necesitamos transparencia en el canvas principal
> - `desynchronized: true` para mejor rendimiento
> - `imageSmoothingEnabled: false` para pixel art sin suavizado
> 
> Si el juego creciera en complejidad (miles de sprites, efectos avanzados), considerar√≠a WebGL o una librer√≠a, pero para este proyecto Canvas API fue la mejor opci√≥n."

**Apoyo Visual**: Mostrar configuraci√≥n del canvas en `render.ts`.

---

### Pregunta 4: "Expl√≠came tu estrategia de optimizaci√≥n de rendimiento"

**Respuesta Preparada**:

> "Implement√© varias optimizaciones basadas en profiling:
> 
> **1. Frame Rate Adaptativo**:
> - Desktop: 60 FPS para experiencia fluida
> - Mobile: 30 FPS para mejor rendimiento y bater√≠a
> - Detecto autom√°ticamente el dispositivo
> 
> **2. Lazy Loading**:
> - Carga diferida de m√≥dulos no cr√≠ticos usando dynamic imports
> - Reduce bundle inicial de ~500KB a ~200KB
> - Los m√≥dulos se cargan solo cuando el juego est√° en estado 'playing'
> 
> **3. Carga Progresiva de Assets**:
> - Assets cr√≠ticos primero (jugador, terreno) -> ~200KB
> - Assets no cr√≠ticos despu√©s en background (enemigos, efectos) -> ~300KB
> - Mejora tiempo de carga inicial de 2s a 0.5s
> 
> **4. Optimizaciones de Canvas**:
> - Configuraci√≥n optimizada del contexto
> - Renderizado solo de entidades visibles (frustum culling b√°sico)
> 
> Puedo mostrar el c√≥digo de lazy loading y la detecci√≥n de dispositivo."

**Apoyo Visual**: Mostrar c√≥digo de lazy loading en `main.ts`.

---

### Pregunta 5: "¬øC√≥mo aplicaste principios SOLID?"

**Respuesta Preparada**:

> "Apliqu√© SOLID de manera progresiva:
> 
> **En el c√≥digo principal**:
> - **SRP**: Separ√© componentes por responsabilidad (player.ts, enemy.ts, render.ts)
> - **OCP**: Sistema extensible de enemigos usando switch por tipo (f√°cil agregar nuevos sin modificar c√≥digo)
> - **LSP**: Interfaces consistentes (`GameObject`) permiten funciones gen√©ricas de colisi√≥n
> 
> **En la refactorizaci√≥n (`src/scripts/solid/`)**:
> - **ISP**: Interfaces segregadas (`IMovable`, `IAnimatable`, `ICollidable`)
> - **DIP**: Inyecci√≥n de dependencias con `DependencyContainer`
> - Abstracciones (`IRenderer`, `IAudioService`, `IInputProvider`)
> 
> El c√≥digo legacy funciona correctamente, y la refactorizaci√≥n muestra el camino hacia una arquitectura m√°s profesional y testeable.
> 
> Puedo mostrar la diferencia entre c√≥digo legacy y SOLID refactorizado."

**Apoyo Visual**: Comparar `enemy.ts` (legacy) con `solid/entities/enemies/` (refactorizado).

---

## üèóÔ∏è Explicaci√≥n de Decisiones Arquitect√≥nicas

### Decisi√≥n 1: TypeScript Estricto

**Qu√© decid√≠**: Usar TypeScript con configuraci√≥n estricta.

**Por qu√©**:
- Detecci√≥n temprana de errores en tiempo de compilaci√≥n
- Mejor autocompletado y Developer Experience
- Documentaci√≥n impl√≠cita a trav√©s de tipos
- Facilita refactoring seguro

**Alternativas consideradas**:
- JavaScript: Rechazado por falta de seguridad de tipos
- TypeScript relajado: Rechazado para mantener calidad de c√≥digo

**Ejemplo**:
```typescript
// Con TypeScript estricto, este error se detecta en compilaci√≥n:
function updateEnemy(enemy: Enemy) {
    enemy.fakeProperty = 123; // ‚ùå Error: Property 'fakeProperty' does not exist
}
```

---

### Decisi√≥n 2: Estado Global (GameStore)

**Qu√© decid√≠**: Estado global centralizado mediante `GameStore`.

**Por qu√©**:
- Sistemas interdependientes (player, enemies, UI, audio)
- Evita prop drilling
- Facilita debugging (un solo lugar)

**Riesgos y mitigaciones**:
- **Riesgo**: Estado global puede volverse dif√≠cil de manejar
- **Mitigaci√≥n**: Documentaci√≥n clara, estructura clara, refactorizaci√≥n en `solid/`

**Ejemplo**:
```typescript
// Estado global facilita acceso desde cualquier componente
export const updatePlayer = (store: GameStore) => {
    // Acceso directo a player, enemies, walls, etc.
    store.player.x += store.player.vx;
    checkCollisions(store.player, store.walls);
};
```

---

### Decisi√≥n 3: Canvas API vs Librer√≠as

**Qu√© decid√≠**: Canvas 2D API nativo, sin librer√≠as.

**Por qu√©**:
- Control total sobre rendering
- Sin dependencias pesadas
- Adecuado para pixel art 2D
- Mejor rendimiento para este caso de uso

**Alternativas consideradas**:
- WebGL: Sobre-ingenier√≠a para 2D simple
- Phaser/Pixi.js: A√±aden ~200KB+ de bundle

**Ejemplo**:
```typescript
// Configuraci√≥n optimizada
const ctx = canvas.getContext('2d', {
    alpha: false,              // No necesitamos transparencia
    desynchronized: true       // Rendering m√°s r√°pido
});
ctx.imageSmoothingEnabled = false; // Pixel art sin suavizado
```

---

## üé® Principios SOLID en Pr√°ctica

### Single Responsibility Principle (SRP)

**Ejemplo en el c√≥digo**:

```typescript
// ‚úÖ CORRECTO: Cada componente tiene una responsabilidad
components/
‚îú‚îÄ‚îÄ player.ts      # Solo l√≥gica del jugador
‚îú‚îÄ‚îÄ enemy.ts        # Solo l√≥gica de enemigos
‚îú‚îÄ‚îÄ render.ts       # Solo renderizado visual
‚îî‚îÄ‚îÄ level.ts        # Solo gesti√≥n de niveles
```

**Por qu√© es importante**:
- Facilita el debugging: Si hay un bug en el jugador, s√© exactamente d√≥nde buscar
- Facilita el testing: Puedo testear l√≥gica sin renderizado
- Facilita la colaboraci√≥n: Dos desarrolladores pueden trabajar en paralelo

---

### Open/Closed Principle (OCP)

**Ejemplo en el c√≥digo**:

```typescript
// ‚úÖ EXTENSIBLE: Puedo agregar nuevos enemigos sin modificar c√≥digo existente
export const updateEnemies = (store: GameStore) => {
    store.enemies.forEach(enemy => {
        switch (enemy.type) {
            case 'bat': updateBat(enemy); break;
            case 'spider': updateSpider(enemy); break;
            case 'viper': updateViper(enemy); break;
            // ‚úÖ Nuevos enemigos: solo agregar nuevo case
            case 'dragon': updateDragon(enemy); break;
        }
    });
};
```

**Mejora futura** (implementada en `solid/`):
```typescript
// ‚úÖ Sistema extensible con interfaces
interface IEnemy {
    update(context: GameContext): void;
}

class DragonEnemy implements IEnemy {
    update(context: GameContext): void {
        // Implementaci√≥n espec√≠fica
    }
}

// ‚úÖ Agregar nuevo enemigo: solo crear nueva clase, sin modificar c√≥digo existente
```

---

### Dependency Inversion Principle (DIP)

**Ejemplo en el c√≥digo**:

**C√≥digo Legacy** (funcional pero acoplado):
```typescript
// ‚ö†Ô∏è Acoplamiento directo con Canvas
export const renderGame = (store: GameStore) => {
    const ctx = store.dom.ctx; // Dependencia directa
    // ...
};
```

**C√≥digo Refactorizado** (en `solid/`):
```typescript
// ‚úÖ Dependencia de abstracci√≥n
interface IRenderer {
    clear(): void;
    drawSprite(sprite: Sprite, position: Vector2): void;
}

class Game {
    constructor(private renderer: IRenderer) {} // ‚úÖ Depende de abstracci√≥n
}

// ‚úÖ F√°cil cambiar implementaci√≥n
const canvasRenderer = new CanvasRenderer();
const webglRenderer = new WebGLRenderer();
const game1 = new Game(canvasRenderer);
const game2 = new Game(webglRenderer);
```

---

## üíª Demostraci√≥n de C√≥digo

### Ejemplo 1: Lazy Loading

**Ubicaci√≥n**: `src/scripts/main.ts:155-171`

**C√≥digo**:
```typescript
// DECISI√ìN T√âCNICA: Lazy loading de m√≥dulos no cr√≠ticos
const [
    { updateEnemies, updateMiner },
    { updateLasers },
    { updateBombs, updateExplosions },
    // ...
] = await Promise.all([
    import('./components/enemy'),
    import('./components/laser'),
    import('./components/bomb'),
    // ...
]);
```

**Explicaci√≥n**:
- Estos m√≥dulos solo se cargan cuando el juego est√° en estado 'playing'
- Reduce bundle inicial de ~500KB a ~200KB
- Mejora tiempo de carga inicial
- Usa `Promise.all` para cargar en paralelo

---

### Ejemplo 2: Frame Rate Adaptativo

**Ubicaci√≥n**: `src/scripts/main.ts:199-210`

**C√≥digo**:
```typescript
const isMobile = (): boolean => {
    return /Android|webOS|iPhone|iPad/i.test(navigator.userAgent) ||
           (window.innerWidth <= 1024);
};

const targetFPS = isMobile() ? 30 : 60;
const frameTime = 1000 / targetFPS;
```

**Explicaci√≥n**:
- Detecta autom√°ticamente el dispositivo
- Ajusta FPS seg√∫n plataforma
- Mejora rendimiento en m√≥vil
- Ahorra bater√≠a en dispositivos m√≥viles

---

### Ejemplo 3: Inyecci√≥n de Dependencias (SOLID)

**Ubicaci√≥n**: `src/scripts/solid/DependencyContainer.ts`

**C√≥digo**:
```typescript
export class DependencyContainer {
    private services = new Map<string, any>();
    
    register<T>(key: string, factory: () => T): void {
        this.services.set(key, factory);
    }
    
    resolve<T>(key: string): T {
        const factory = this.services.get(key);
        if (!factory) {
            throw new Error(`Service ${key} not found`);
        }
        return factory();
    }
}
```

**Explicaci√≥n**:
- Container centralizado de dependencias
- Facilita testing con mocks
- Permite cambiar implementaciones f√°cilmente
- Aplica Dependency Inversion Principle

---

## ‚ùì Preguntas para Hacer

### Preguntas T√©cnicas

1. **"¬øQu√© principios arquitect√≥nicos prefieren en su equipo?"**
   - Te permite alinear tu experiencia con sus est√°ndares
   - Muestra inter√©s en aprender sus pr√°cticas

2. **"¬øC√≥mo manejan el c√≥digo legacy en proyectos grandes?"**
   - Puedes relacionarlo con tu estrategia de migraci√≥n progresiva
   - Muestra experiencia real con refactoring

3. **"¬øQu√© herramientas usan para medir performance?"**
   - Puedes mencionar que usas Chrome DevTools
   - Muestra conocimiento de profiling

4. **"¬øC√≥mo estructuran sus proyectos TypeScript?"**
   - Puedes comparar con tu estructura
   - Muestra que puedes adaptarte

### Preguntas sobre el Proyecto

1. **"¬øHay alg√∫n aspecto del proyecto que les gustar√≠a que mejorara?"**
   - Muestra autocr√≠tica
   - Demuestra ganas de mejorar

2. **"¬øC√≥mo puedo aplicar principios SOLID a√∫n m√°s efectivamente?"**
   - Muestra humildad
   - Demuestra ganas de aprender

---

## üéØ Checklist Pre-Entrevista

- [ ] Revis√© `ARCHITECTURE_DECISIONS.md`
- [ ] Revis√© `SOLID_REFACTORING.md`
- [ ] Tengo 3-5 ejemplos de c√≥digo listos
- [ ] Puedo explicar cada decisi√≥n t√©cnica
- [ ] Puedo demostrar principios SOLID aplicados
- [ ] Tengo preguntas preparadas
- [ ] Tengo el proyecto corriendo localmente
- [ ] Tengo acceso a la documentaci√≥n

---

## üìù Notas Finales

- **S√© honesto**: Si algo no lo sabes, adm√≠telo y muestra ganas de aprender
- **Muestra curiosidad**: Pregunta sobre c√≥mo hacen las cosas ellos
- **Destaca el aprendizaje**: Explica qu√© aprendiste del proyecto
- **Menciona mejoras**: S√© cr√≠tico con tu c√≥digo y menciona qu√© har√≠as diferente

**Recuerda**: No tienes que ser perfecto. Lo importante es demostrar:
- ‚úÖ Capacidad de tomar decisiones t√©cnicas justificadas
- ‚úÖ Conocimiento de principios de ingenier√≠a de software
- ‚úÖ Ganas de aprender y mejorar
- ‚úÖ Pensamiento cr√≠tico sobre el c√≥digo

¬°√âxito en tu entrevista! üöÄ

